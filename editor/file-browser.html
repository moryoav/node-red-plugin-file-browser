<script type="text/javascript">
(function() {
  // ---------- Styles for pulse highlight ----------
  function ensureStyle() {
    if (document.getElementById("fb-style")) return;
    const css = `
      .fb-row { display:flex; align-items:center; padding:4px 2px; cursor:pointer; }
      .fb-ref-link { opacity:0.9; margin-right:6px; cursor:pointer; }
      .fb-ref-link:hover { opacity:1; }
      @keyframes fb-node-pulse {
        0%   { box-shadow: 0 0 0 0 rgba(66,165,245,0.95); }
        70%  { box-shadow: 0 0 0 10px rgba(66,165,245,0); }
        100% { box-shadow: 0 0 0 0 rgba(66,165,245,0); }
      }
      .fb-flash {
        animation: fb-node-pulse 1.8s ease-out 0s 1;
        outline: 2px solid var(--red-ui-primary-background, #268bd2);
        outline-offset: 2px;
        border-radius: 6px;
      }
      .red-ui-button.fb-danger:not(.disabled){
        background-color: #d9534f;
        color: #000000 !important;
        border-color: #b52b27;
        font-weight: 600;
        text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      }
      .red-ui-button.fb-danger:not(.disabled):hover{ filter: brightness(0.95); }
      .fb-debug-panel {
        position: absolute; right: 8px; bottom: 8px; width: 460px; max-height: 50%;
        overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 11px; background: rgba(0,0,0,0.78); color:#cfe3ff; border-radius: 8px;
        padding: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.25); z-index: 50; display:none;
      }
      .fb-debug-panel pre { margin:0; white-space:pre-wrap; word-break:break-word; }
      .fb-debug-toggle { margin-left: 6px; }
    `;
    const s = document.createElement("style");
    s.id = "fb-style";
    s.textContent = css;
    document.head.appendChild(s);
  }

  // ---- Debug master switch (OFF by default) ----
  const FB_DEBUG_KEY = "filebrowser.debug";
  const FB_DEBUG_DEFAULT = false; // set true to ship with debug ON by default
  function fbDebugEnabled() {
    return localStorage.getItem(FB_DEBUG_KEY) === "1" || FB_DEBUG_DEFAULT;
  }
  // Console helpers to toggle without editing code:
  window.FB_DEBUG_ON  = () => { localStorage.setItem(FB_DEBUG_KEY, "1"); location.reload(); };
  window.FB_DEBUG_OFF = () => { localStorage.removeItem(FB_DEBUG_KEY); location.reload(); };

  // ---------- Lightweight debug logger (no-op when master is OFF) ----------
  const DBG = (() => {
    const buf = [];
    let enabled = false;   // panel visibility, separate from master switch
    let panel = null;
    function ts(){ return new Date().toISOString().slice(11,19); }
    function ensurePanel(){
      if (!fbDebugEnabled()) return null; // don't create panel when master off
      if (panel) return panel;
      panel = document.createElement("div");
      panel.className = "fb-debug-panel";
      panel.id = "fb-debug-panel";
      const pre = document.createElement("pre");
      pre.id = "fb-debug-pre";
      panel.appendChild(pre);
      document.body.appendChild(panel);
      return panel;
    }
    function render(){
      if (!fbDebugEnabled() || !panel) return;
      const pre = panel.querySelector("#fb-debug-pre");
      if (pre) pre.textContent = buf.join("\n");
    }
    return {
      log: (...a) => {
        if (!fbDebugEnabled()) return; // silent when master off
        const line = `[${ts()}] ${a.map(x=> (typeof x==='object'?JSON.stringify(x):String(x))).join(" ")}`;
        buf.push(line); if (buf.length>600) buf.shift();
        console.log("[file-browser]", ...a);
        render();
      },
      toggle: () => { // toggles panel visibility (only when master on)
        if (!fbDebugEnabled()) return false;
        enabled = !enabled;
        const p = ensurePanel();
        if (p) p.style.display = enabled ? "block" : "none";
        return enabled;
      },
      ensurePanel
    };
  })();

  // ---------- Monaco loader (with textarea fallback) ----------
  function loadScript(src){
    return new Promise((res,rej)=>{
      const s=document.createElement("script");
      s.src=src;s.onload=res;s.onerror=()=>rej(new Error("load fail "+src));
      document.head.appendChild(s);
    });
  }
  const MonacoReady=(function(){let p=null;return function(){
    if(p)return p;
    p=new Promise(async(res,rej)=>{
      if(window.monaco&&window.monaco.editor)return res(window.monaco);
      if(!window.require){
        try{await loadScript("https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs/loader.min.js");}
        catch(e){return rej(e);}
      }
      try{
        window.require.config({paths:{vs:"https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs"}});
        window.require(["vs/editor/editor.main"],()=>window.monaco&&window.monaco.editor?res(window.monaco):rej(new Error("monaco init failed")));
      }catch(e){rej(e);}
    });
    return p;
  };})();

  // ---------- Admin ajax ----------
  function ajax(method, url, data) {
    return $.ajax({
      method,
      url,
      data: data ? JSON.stringify(data) : undefined,
      contentType: data ? "application/json" : undefined,
      headers: { "Node-RED-API-Version": "v2" },
      xhrFields: { withCredentials: true }
    });
  }

  // ---------- Reveal & pulse helpers ----------
  function nodeElementById(id) { return document.querySelector('[data-nodeid="'+id+'"]'); }
  function revealNodeById(nodeId) {
    const n = RED.nodes.node(nodeId);
    if (!n) { RED.notify("Node not found in current flows","warning"); return; }
    if (n.z && RED.workspaces && typeof RED.workspaces.show === "function") { RED.workspaces.show(n.z); }
    const doFlash = () => {
      try { if (RED.view && typeof RED.view.reveal === "function") { RED.view.reveal(n.id, true); } } catch(e){}
      const el = nodeElementById(n.id);
      if (el) {
        el.classList.add("fb-flash");
        setTimeout(()=>{ el.classList.remove("fb-flash"); }, 1800);
      } else if (RED.view && typeof RED.view.select === "function") {
        try { RED.view.select(n); } catch(e){}
      }
    };
    window.requestAnimationFrame(()=> setTimeout(doFlash, 50));
  }

  // ---------- Plugin ----------
  RED.plugins.registerPlugin("file-browser", {
    onadd: function() {
      ensureStyle();

      const $root   = $("<div>").css({position:"relative", height:"100%", display:"flex", gap:"8px"});

      // Left panel (tree + base controls)
      const $left   = $("<div>").css({width:"38%", minWidth:"280px", height:"100%", display:"flex", flexDirection:"column", borderRight:"1px solid var(--red-ui-secondary-background)"});
      const $leftHdr= $("<div>").css({
        padding:"8px",
        display:"grid",
        gridTemplateColumns:"auto 1fr auto auto", /* label | input | change | refresh */
        gap:"6px",
        alignItems:"center",
        borderBottom:"1px solid var(--red-ui-secondary-background)"
      });
      const $baseLabel = $('<span style="font-size:0.8em;opacity:0.8;white-space:nowrap;align-self:center;">Base:</span>');
      const $baseWrap  = $("<div>").css({display:"flex", alignItems:"center", width:"100%"});
      const $baseInput = $('<input type="text" readonly>').css({
        width:"100%", height:"28px", lineHeight:"26px", padding:"0 8px", fontSize:"0.85em", boxSizing:"border-box", margin:0
      });
      $baseWrap.append($baseInput);
      const $btnChangeBase= $('<button class="red-ui-button" title="Change baseâ€¦"><i class="fa fa-folder-open"></i></button>');
      const $btnRefreshL  = $('<button class="red-ui-button" title="Refresh"><i class="fa fa-refresh"></i></button>');
      const $treeWrap= $("<div>").css({flex:"1 1 auto", overflow:"auto"});
      const $tree   = $("<div>").attr("id","fb-tree").css({padding:"6px"});

      $leftHdr.append($baseLabel, $baseWrap, $btnChangeBase, $btnRefreshL);
      $treeWrap.append($tree);
      $left.append($leftHdr, $treeWrap);

      // Right panel (editor + ops)
      const $right  = $("<div>").css({flex:"1 1 auto", height:"100%", display:"flex", flexDirection:"column"});
      const $toolbar= $("<div>").css({padding:"6px", display:"flex", gap:"6px", alignItems:"center", borderBottom:"1px solid var(--red-ui-secondary-background)"});
      const $crumb  = $("<div>").css({fontSize:"0.85em", opacity:0.8, flex:"1 1 auto", overflow:"hidden", textOverflow:"ellipsis", whiteSpace:"nowrap"});

      const $btnNewFile    = $('<button class="red-ui-button"><i class="fa fa-file-o"></i> New file</button>');
      const $btnRenameFile = $('<button class="red-ui-button"><i class="fa fa-pencil"></i> Rename file</button>').prop("disabled", true);
      const $btnDeleteFile = $('<button class="red-ui-button"><i class="fa fa-trash"></i> Delete</button>').prop("disabled", true);
      const $btnNewDir     = $('<button class="red-ui-button"><i class="fa fa-folder-o"></i> New folder</button>');
      const $btnSave       = $('<button class="red-ui-button"><i class="fa fa-save"></i> Save</button>').prop("disabled", true);
      const $btnDebug      = $('<button class="red-ui-button fb-debug-toggle" title="Toggle debug"><i class="fa fa-bug"></i></button>')
        .on("click", ()=>{ const on = DBG.toggle(); RED.notify(on?"Debug ON":"Debug OFF","compact"); });

      const $editorHost = $("<div>").attr("id","fb-editor").css({flex:"1 1 auto", position:"relative", minHeight:"220px"});
      const $status     = $("<div>").css({padding:"4px 8px", borderTop:"1px solid var(--red-ui-secondary-background)", fontSize:"0.85em", opacity:0.8});

      // Keep original order; add bug button only if debug master is ON
      $toolbar.append($btnNewFile, $btnRenameFile, $btnDeleteFile, $btnNewDir, $btnSave, $crumb);
      if (fbDebugEnabled()) $toolbar.append($btnDebug);

      $right.append($toolbar, $editorHost, $status);
      $root.append($left, $right);

      // ---------- State ----------
      let baseInfo = { baseDir:"", userDir:"" };
      let currentDir = ".";
      let currentFile = null;
      let monacoEditor = null, textarea = null, editorKind = "none";
      let dirty = false;

      // Monaco persistent model state
      let editorModel = null;
      let editorModelUri = null;
      let currentTextCache = "";
      let suppressDirty = false;

      // on-disk tracking
      let lastDisk = { mtime: null, size: null };
      let statTimer = null;
      let onDiskChanged = false;

      // referenced files: path -> { names:[], ids:[] }
      let referencedMap = new Map();

      function toast(msg,type){ try { RED.notify(msg,{type:type||"success",timeout:1800}); } catch(e){ RED.notify(msg,type||"success"); } }
      function notifyErr(x){ try { RED.notify(x,{type:"error",timeout:2500}); } catch(e){ RED.notify(x,"error"); } }
      function setStatus(t){ $status.text(t||""); }

      function layoutEditorSoon() {
        if (editorKind === "monaco" && monacoEditor) {
          requestAnimationFrame(() => {
            try { monacoEditor.layout(); } catch(e){}
          });
        }
      }

      function ensureMonacoModel(filename){
        if (editorKind !== "monaco" || !monacoEditor || !window.monaco) return;
        if (!editorModelUri) {
          editorModelUri = window.monaco.Uri.parse("inmemory://file-browser/current");
        }
        const lang = langFromFilename(filename||"");
        if (!editorModel || editorModel.isDisposed()) {
          editorModel = window.monaco.editor.createModel(currentTextCache || "", lang, editorModelUri);
          monacoEditor.setModel(editorModel);
        } else {
          window.monaco.editor.setModelLanguage(editorModel, lang);
          if (monacoEditor.getModel() !== editorModel) {
            monacoEditor.setModel(editorModel);
          }
        }
      }

      // ---------- VIEW STATE MEMORY (v3) ----------
      const VS_KEY_PREFIX = "fb-vs-v3::";     // per-file key (relative path only)
      let restoreInProgress = false;
      let restoreGuardUntil = 0;              // timestamp (ms) until we ignore scroll/cursor events
      let posDebounceTimer = null;

      function keyFor(rel){ return VS_KEY_PREFIX + (rel||""); }
      function lsSet(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){ DBG.log("lsSet error",e.message); } }
      function lsGet(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch(e){ DBG.log("lsGet error",e.message); return null; } }
      function lsDel(k){ try{ localStorage.removeItem(k); }catch(e){ DBG.log("lsDel error",e.message); } }

      function now(){ return Date.now(); }
      function startRestoreGuard(durationMs){
        restoreInProgress = true;
        restoreGuardUntil = now() + (durationMs||800);
        DBG.log("restore-guard-start", {until: restoreGuardUntil});
        setTimeout(()=>{ restoreInProgress = false; DBG.log("restore-guard-end"); }, durationMs||800);
      }
      function shouldIgnoreChanges(src){
        const ignore = restoreInProgress || now() < restoreGuardUntil;
        if (ignore) DBG.log("ignore-event", src, {restoreInProgress, now: now(), guardUntil: restoreGuardUntil});
        return ignore;
      }
      function sanitizeMonacoScroll(v){
        if (typeof v !== "number") return null;
        if (v < 0) return null; // invalid
        return v;
      }

      function saveViewState(tag){
        if (!currentFile) return;
        if (editorKind==="monaco" && monacoEditor){
          try {
            const vs = monacoEditor.saveViewState();
            const st = {
              kind: "monaco-vs",
              viewState: vs || null,
              scrollTop: sanitizeMonacoScroll(monacoEditor.getScrollTop()),
              scrollLeft: sanitizeMonacoScroll(monacoEditor.getScrollLeft())
            };
            if (st.scrollTop === null) { DBG.log("remember-skip-invalid", tag||"", currentFile, st); return; }
            if (shouldIgnoreChanges("remember-"+(tag||""))) return; // ignore during guard
            lsSet(keyFor(currentFile), st);
            DBG.log("remember", tag||"", currentFile, st);
          } catch(e){ DBG.log("remember error", e.message); }
        } else if (editorKind==="textarea" && textarea){
          const el = textarea[0]; if (!el) return;
          const st = {
            kind: "textarea-v2",
            selectionStart: (typeof el.selectionStart === "number") ? el.selectionStart : null,
            selectionEnd:   (typeof el.selectionEnd   === "number") ? el.selectionEnd   : null,
            scrollTop: el.scrollTop || 0,
            scrollLeft: el.scrollLeft || 0
          };
          if (shouldIgnoreChanges("remember-textarea-"+(tag||""))) return;
          lsSet(keyFor(currentFile), st);
          DBG.log("remember-textarea", tag||"", currentFile, st);
        }
      }
      function scheduleRemember(tag){
        if (posDebounceTimer) clearTimeout(posDebounceTimer);
        posDebounceTimer = setTimeout(()=>saveViewState(tag), 160);
      }

      function applyRestore(relPath, st){
        if (!st) return false;
        try{
          if (editorKind==="monaco" && monacoEditor){
            if (st.viewState) {
              monacoEditor.restoreViewState(st.viewState);
              monacoEditor.focus();
              DBG.log("restore-applied-vs", relPath, {hasViewState:true});
            } else {
              const model = monacoEditor.getModel && monacoEditor.getModel();
              const maxLine = model ? Math.max(1, model.getLineCount()) : 1;
              const line = Math.max(1, Math.min(st.line||1, maxLine));
              const col  = Math.max(1, st.column||1);
              monacoEditor.setPosition({ lineNumber: line, column: col });
              if (typeof st.scrollTop  === "number" && st.scrollTop  >= 0) monacoEditor.setScrollTop(st.scrollTop);
              if (typeof st.scrollLeft === "number" && st.scrollLeft >= 0) monacoEditor.setScrollLeft(st.scrollLeft);
              monacoEditor.revealPositionInCenterIfOutsideViewport({ lineNumber: line, column: col });
              DBG.log("restore-applied-legacy", relPath, {line, col, scrollTop:st.scrollTop, scrollLeft:st.scrollLeft});
            }
            return true;
          } else if (editorKind==="textarea" && textarea){
            const el = textarea[0]; if (!el) return false;
            if (typeof st.selectionStart === "number" && typeof st.selectionEnd === "number") {
              el.selectionStart = st.selectionStart;
              el.selectionEnd   = st.selectionEnd;
            }
            if (typeof st.scrollTop  === "number" && st.scrollTop  >= 0) el.scrollTop  = st.scrollTop;
            if (typeof st.scrollLeft === "number" && st.scrollLeft >= 0) el.scrollLeft = st.scrollLeft;
            DBG.log("restore-applied-textarea", relPath, st);
            return true;
          }
        }catch(e){ DBG.log("restore error", e.message); }
        return false;
      }
      function restorePositionFor(relPath, opts){
        relPath = relPath || currentFile;
        if (!relPath) return;
        const st = lsGet(keyFor(relPath));
        DBG.log("restore-start", relPath, st);
        const retries = (opts&&opts.retries)||14;
        const delay   = (opts&&opts.delay)||60;
        let attempt = 0;

        startRestoreGuard((opts&&opts.guardMs) || 800);

        function tryApply(){
          attempt++;
          const ok = applyRestore(relPath, st);
          if (!ok && attempt < retries){
            setTimeout(tryApply, delay);
            DBG.log("restore-retry", relPath, {attempt, retries});
          } else {
            DBG.log("restore-done", relPath, {ok, attempt});
          }
        }
        setTimeout(tryApply, 0);
      }
      window.addEventListener("beforeunload", ()=>saveViewState("beforeunload"));

      // ---------- Crumbs ----------
      function setCrumb(parts) {
        const segs = [];
        const acc = [];
        segs.push($('<a href="#">.</a>').on('click', (e)=>{ e.preventDefault(); loadList("."); }));
        (parts||[]).forEach((p)=>{
          acc.push(p);
          segs.push($('<span>/</span>'));
          segs.push($('<a href="#"></a>').text(p).on('click', (e)=>{ e.preventDefault(); loadList(acc.join("/")); }));
        });
        $crumb.empty().append(segs);
      }

      // ---------- Icons & rows ----------
      function iconFor(it, meta){
        const $ico = $('<i class="fa"></i>').addClass(it.type==="dir"?"fa-folder":"fa-file-text-o").css({width:"16px",marginRight:"6px"});
        if (it.type==="file" && meta) {
          const names = meta.names && meta.names.length ? meta.names : [];
          const tip = names.length
            ? `Click to reveal: ${names[0]}` + (names.length>1 ? `\nAlso in: ${names.slice(1,6).join(", ")}${names.length>6?` (+${names.length-6} more)`:``}` : ``)
            : "Referenced in flow(s)";
          const firstId = (meta.ids && meta.ids[0]) || null;
          const $mark = $('<i class="fa fa-link fb-ref-link"></i>').attr("title", tip);
          if (firstId) {
            $mark.on("click", (e)=>{ e.stopPropagation(); revealNodeById(firstId); });
          }
          return [$mark, $ico];
        }
        return [$ico];
      }
      function rowUp(){
        const $r=$('<div class="fb-row">').css({display:"flex",alignItems:"center",padding:"4px 2px",cursor:"pointer"});
        $r.append($('<i class="fa fa-level-up"></i>').css({width:"16px",marginRight:"6px"}), $('<span>').text(".."));
        $r.on('click', ()=>{ const parent = currentDir.split("/").filter(Boolean).slice(0,-1).join("/") || "."; loadList(parent); });
        return $r;
      }

      function renderTree(list){
        baseInfo.baseDir = list.baseDir || baseInfo.baseDir;
        baseInfo.userDir = list.userDir || baseInfo.userDir;
        $baseInput.val(baseInfo.baseDir || "");

        currentDir = list.cwd;
        setCrumb(list.breadcrumb);
        $tree.empty();

        const rows=[];
        if (list.cwd!==".") rows.push(rowUp());
        list.items.forEach((it)=>{
          const meta = (it.type==="file") ? referencedMap.get(it.path) : null;
          const $r=$('<div class="fb-row">').css({display:"flex",alignItems:"center",padding:"4px 2px",cursor:"pointer"});

          const icons = iconFor(it, meta);
          icons.forEach(n=> $r.append(n));

          const $name = $('<span>').text(it.name).css({flex:"1 1 auto"});
          if (meta && meta.names && meta.names.length) {
            $r.attr("title", "Referenced by: " + meta.names.join(", "));
          }
          $r.append($name);

          if (it.type==="dir") $r.on('click', ()=> loadList(it.path));
          else $r.on('click', ()=> openFile(it.path));

          rows.push($r);
        });
        rows.forEach(r=>$tree.append(r));
      }

      // ---------- Loaders ----------
      function loadConfigThenList() {
        ajax("GET", "filebrowser/config")
          .done((cfg)=>{ baseInfo = cfg || baseInfo; $baseInput.val(baseInfo.baseDir||""); scanFlows(); loadList("."); })
          .fail(()=>{ scanFlows(); loadList("."); });
      }

      function loadList(dir) {
        ajax("GET", "filebrowser/list?path="+encodeURIComponent(dir))
          .done((res)=>{ renderTree(res); setStatus("Listed: "+res.cwd); })
          .fail((xhr)=>{ console.error("[file-browser] list error", xhr.status, xhr.responseText); notifyErr("List error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)); });
      }

      // ---------- Flows scan (client) ----------
      function scanFlows() {
        ajax("GET","filebrowser/scan-flows")
          .done((res)=>{
            const map = new Map();
            if (res && Array.isArray(res.referenced)) {
              for (const item of res.referenced) {
                const rel = (item && item.path) ? String(item.path) : null;
                if (!rel) continue;
                const nodes = Array.isArray(item.nodes) ? item.nodes : [];
                const names = nodes.map(n => (n && n.name) ? String(n.name) : "").filter(Boolean);
                const ids   = nodes.map(n => (n && n.id)   ? String(n.id)   : "").filter(Boolean);
                map.set(rel, { names, ids });
              }
            }
            referencedMap = map;
            if ($tree.children().length) loadList(currentDir);
          })
          .fail((xhr)=>{ console.warn("[file-browser] scan-flows error", xhr.status, xhr.responseText); /* non-fatal */ });
      }

      // ---------- Editor ----------
      function ensureEditorReady(){
        if (editorKind==="monaco" && monacoEditor) return Promise.resolve("monaco");
        if (editorKind==="textarea" && textarea)   return Promise.resolve("textarea");
        return MonacoReady().then(()=>{
          monacoEditor = window.monaco.editor.create($editorHost[0], { value:"", language:"plaintext", automaticLayout:true, minimap:{enabled:false} });

          editorModelUri = window.monaco.Uri.parse("inmemory://file-browser/current");
          editorModel = window.monaco.editor.createModel("", "plaintext", editorModelUri);
          monacoEditor.setModel(editorModel);

          monacoEditor.onDidChangeModelContent(()=>{
            if (suppressDirty) {
              try { currentTextCache = monacoEditor.getValue(); } catch(e){}
              return;
            }
            if (currentFile){ markDirty(true); }
            try { currentTextCache = monacoEditor.getValue(); } catch(e){}
          });

          // View-state listeners (guarded)
          if (typeof monacoEditor.onDidScrollChange === "function") {
            monacoEditor.onDidScrollChange(()=>{ if (!shouldIgnoreChanges("scroll")) scheduleRemember("scroll"); });
          }
          if (typeof monacoEditor.onDidChangeCursorPosition === "function") {
            monacoEditor.onDidChangeCursorPosition(()=>{ if (!shouldIgnoreChanges("cursor")) scheduleRemember("cursor"); });
          }

          layoutEditorSoon();
          editorKind="monaco";

          if (currentFile) { restorePositionFor(currentFile); }
          return "monaco";
        }).catch(()=>{
          textarea = $("<textarea>").css({position:"absolute", inset:"0", width:"100%", height:"100%", fontFamily:"monospace", fontSize:"12px", padding:"8px", boxSizing:"border-box"});
          $editorHost.empty().append(textarea);
          textarea.on("input", ()=>{ if (currentFile){ markDirty(true);} if (!shouldIgnoreChanges("ta-input")) scheduleRemember("input"); });
          textarea.on("scroll", ()=>{ if (!shouldIgnoreChanges("ta-scroll")) scheduleRemember("scroll"); });
          textarea.on("keyup", ()=>{ if (!shouldIgnoreChanges("ta-keyup")) scheduleRemember("keyup"); });
          editorKind="textarea";
          if (currentFile) { restorePositionFor(currentFile); }
          return "textarea";
        });
      }
      function langFromFilename(name){
        const ext=(name.split(".").pop()||"").toLowerCase();
        const map={js:"javascript",ts:"typescript",py:"python",json:"json",md:"markdown",html:"html",css:"css",yml:"yaml",yaml:"yaml",sh:"shell",bat:"bat",
                   c:"c",cpp:"cpp",h:"cpp",hpp:"cpp",java:"java",cs:"csharp",rs:"rust",go:"go",sql:"sql",xml:"xml",ini:"ini",toml:"toml",txt:"plaintext"};
        return map[ext] || "plaintext";
      }
      function setEditorContent(text, filename){
        if (editorKind==="monaco" && monacoEditor){
          ensureMonacoModel(filename);
          const v = String(text||"");
          suppressDirty = true;
          try { editorModel.setValue(v); } finally { suppressDirty = false; }
          currentTextCache = v;
          layoutEditorSoon();
          // Restore for the file currently open (with guard + retries)
          restorePositionFor(currentFile || filename, {retries:16, delay:60, guardMs:900});
        } else if (editorKind==="textarea" && textarea){
          textarea.val(text);
          restorePositionFor(currentFile || filename, {retries:12, delay:60, guardMs:700});
        }
      }
      function getEditorContent(){
        if (editorKind==="monaco" && monacoEditor) return monacoEditor.getValue();
        if (editorKind==="textarea" && textarea)   return textarea.val();
        return "";
      }

      // ---------- File ops ----------
      function openFile(relPath) {
        // Remember the previous file's position before switching
        saveViewState("switch-away");

        ajax("GET", "filebrowser/open?path="+encodeURIComponent(relPath))
          .done((res)=>{
            ensureEditorReady().then(()=>{
              currentFile=relPath;
              $btnRenameFile.prop("disabled", false);
              $btnDeleteFile.prop("disabled", false);
              lastDisk = { mtime: res.mtime || null, size: res.size || null };
              onDiskChanged = false;

              setEditorContent(res.text||"", relPath);
              markDirty(false);

              setStatus("Opened: "+relPath);
              startStatTimer();
              layoutEditorSoon();
            });
          })
          .fail((xhr)=>{ console.error("[file-browser] open error", xhr.status, xhr.responseText); notifyErr("Open error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)); });
      }

      function doSave(){
        if (!currentFile) return;
        const text = getEditorContent();
        ajax("POST","filebrowser/save",{ path: currentFile, text })
          .done((r)=>{
            lastDisk = { mtime: r.mtime || Date.now(), size: r.size || (text||"").length };
            onDiskChanged = false;
            markDirty(false);
            setStatus("Saved: "+currentFile);
            toast("Saved","success");
            setTimeout(statCurrent, 500);
            saveViewState("after-save");
          })
          .fail((xhr)=>{ console.error("[file-browser] save error", xhr.status, xhr.responseText); notifyErr("Save error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)); });
      }

      function doRename(){
        if (!currentFile) return;
        const oldPath = currentFile;
        const base = oldPath.split("/").pop();
        const newName = prompt("Rename file to:", base);
        if (newName == null) return;
        const trimmed = String(newName).trim();
        if (!trimmed || trimmed === base) return;
        if (/[\\/:*?"<>|]/.test(trimmed)) { notifyErr("Invalid filename."); return; }

        ajax("POST","filebrowser/rename",{ path: oldPath, newName: trimmed })
          .done((res)=>{
            const content = getEditorContent();
            const oldKey = keyFor(oldPath);
            const oldState = lsGet(oldKey);

            currentFile = res.path || (oldPath.split("/").slice(0,-1).concat([trimmed]).join("/"));
            setEditorContent(content, currentFile);
            markDirty(false);

            if (typeof res.mtime === "number" || typeof res.size === "number") {
              lastDisk = { mtime: res.mtime || lastDisk.mtime, size: res.size ?? lastDisk.size };
            }
            if (oldState) { lsSet(keyFor(currentFile), oldState); lsDel(oldKey); DBG.log("migrate-viewstate", {from:oldPath,to:currentFile}); }
            setStatus("Renamed to: " + currentFile);
            toast("Renamed","success");
            loadList(currentDir);
            scanFlows();
          })
          .fail((xhr)=>{ console.error("[file-browser] rename error", xhr.status, xhr.responseText); notifyErr("Rename error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)); });
      }

      function doDelete(){
        if (!currentFile) return;
        const name = currentFile.split("/").pop();
        const ok = confirm(`Delete "${name}" permanently?`);
        if (!ok) return;
        ajax("POST","filebrowser/delete",{ path: currentFile })
          .done(()=>{
            lsDel(keyFor(currentFile));
            stopStatTimer();
            setStatus("Deleted: " + name);
            toast("Deleted","success");
            currentFile = null;
            $btnRenameFile.prop("disabled", true);
            $btnDeleteFile.prop("disabled", true);
            markDirty(false);
            setEditorContent("", "");
            loadList(currentDir);
            scanFlows();
          })
          .fail((xhr)=>{ console.error("[file-browser] delete error", xhr.status, xhr.responseText); notifyErr("Delete error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)); });
      }

      // ---------- Save button state ----------
      function updateSaveAppearance() {
        if (dirty) { $btnSave.prop("disabled", false).addClass("fb-danger"); }
        else { $btnSave.prop("disabled", true).removeClass("fb-danger"); }
        if (onDiskChanged) { $status.text(($status.text()||"") + " (changed on disk)"); }
      }
      function markDirty(val) { dirty = !!val; updateSaveAppearance(); }

      function stopStatTimer(){ if (statTimer){ clearInterval(statTimer); statTimer=null; } }
      function startStatTimer(){ stopStatTimer(); if (!currentFile) return; statTimer = setInterval(statCurrent, 5000); }
      function statCurrent() {
        if (!currentFile) return;
        ajax("GET", "filebrowser/stat?path="+encodeURIComponent(currentFile))
          .done(res=>{
            const changed = (lastDisk.mtime !== null && (res.mtime !== lastDisk.mtime || res.size !== lastDisk.size));
            onDiskChanged = !!changed;
            if (onDiskChanged) setStatus("Opened: "+currentFile+" (changed on disk)");
            else setStatus("Opened: "+currentFile);
            updateSaveAppearance();
          })
          .fail(()=>{ /* ignore */ });
      }

      // ---------- Controls ----------
      $btnRefreshL.on("click", ()=> { saveViewState("refresh-left"); scanFlows(); loadList(currentDir); });
      $btnChangeBase.on("click", ()=>{
        const suggested = (baseInfo.baseDir?.replace(/\/+$/,'') || "") + (currentDir && currentDir!=='.' ? '/'+currentDir : '');
        const abs = prompt(`Enter absolute base folder path inside userDir:\n(userDir: ${baseInfo.userDir})`,
                           suggested || baseInfo.baseDir || baseInfo.userDir || "");
        if (!abs) return;

        function onOk(cfg){
          baseInfo.baseDir = cfg.baseDir;
          $baseInput.val(baseInfo.baseDir);
          setStatus("Base set to: "+cfg.baseDir);
          toast("Base updated","success");
          scanFlows();
          loadList(".");
        }

        ajax("POST","filebrowser/set-base",{ path: abs })
          .done(onOk)
          .fail((xhr)=>{
            const j = xhr.responseJSON || {};
            if (xhr.status === 400 && j.code === "OUTSIDE_USERDIR") {
              const yn = confirm(
                `Warning: The selected folder is OUTSIDE Node-RED userDir.\n\n` +
                `userDir:\n${j.userDir}\n\nRequested:\n${j.requested}\n\n` +
                `This grants the Files panel access to that folder.\nProceed anyway?`
              );
              if (!yn) { notifyErr("Base not changed."); return; }

              ajax("POST","filebrowser/set-base",{ path: abs, force: true })
                .done(onOk)
                .fail((xhr2)=> notifyErr("Set base error: "+(xhr2.responseJSON?.error || xhr2.statusText || xhr2.status)));
            } else {
              notifyErr("Set base error: "+(j.error || xhr.statusText || xhr.status));
            }
          });
      });

      $btnSave.on("click", doSave);
      $btnRenameFile.on("click", doRename);
      $btnDeleteFile.on("click", doDelete);
      $btnNewFile.on("click", ()=>{
        const name = prompt("New file name:"); if (!name) return;
        ajax("POST","filebrowser/new-file",{ dir: currentDir, name })
          .done((res)=>{ setStatus("Created file: "+res.path); toast("File created","success"); loadList(currentDir); scanFlows(); })
          .fail((xhr)=> notifyErr("New file error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)));
      });
      $btnNewDir.on("click", ()=>{
        const name = prompt("New folder name:"); if (!name) return;
        ajax("POST","filebrowser/new-folder",{ dir: currentDir, name })
          .done((res)=>{ setStatus("Created folder: "+res.path); toast("Folder created","success"); loadList(currentDir); })
          .fail((xhr)=> notifyErr("New folder error: "+(xhr.responseJSON?.error || xhr.statusText || xhr.status)));
      });

      // Warn + revive model when node editor closes
      RED.events.on("editor:close", ()=>{
        if (dirty) RED.notify("Unsaved changes in "+(currentFile||"file"),"warning");
        saveViewState("editor-close");
        setTimeout(()=>{
          if (editorKind==="monaco" && window.monaco) {
            if (!editorModel || editorModel.isDisposed()) {
              ensureMonacoModel(currentFile);
              suppressDirty = true;
              try { editorModel.setValue(currentTextCache); } finally { suppressDirty = false; }
              monacoEditor.setModel(editorModel);
            }
            layoutEditorSoon();
            restorePositionFor(currentFile, {retries:16, delay:60, guardMs:900});
          } else if (editorKind==="textarea") {
            restorePositionFor(currentFile, {retries:12, delay:60, guardMs:700});
          }
        }, 0);
      });

      // Rescan & layout after deploy; and handle resizes
      if (RED && RED.events && RED.events.on) {
        RED.events.on("deploy", ()=> { scanFlows(); });
      }
      RED.events.on("deploy", () => { setTimeout(()=>{ layoutEditorSoon(); restorePositionFor(currentFile, {guardMs:700}); }, 25); });
      RED.events.on("editor:open", () => { layoutEditorSoon(); setTimeout(()=>restorePositionFor(currentFile, {guardMs:700}), 0); });
      RED.events.on("editor:close", () => { setTimeout(layoutEditorSoon, 0); });
      RED.events.on && RED.events.on("workspace:resize", ()=>{ layoutEditorSoon(); setTimeout(()=>restorePositionFor(currentFile, {guardMs:600}), 0); });
      RED.events.on && RED.events.on("sidebar:resize",   ()=>{ layoutEditorSoon(); setTimeout(()=>restorePositionFor(currentFile, {guardMs:600}), 0); });
      window.addEventListener("resize", ()=>{ layoutEditorSoon(); setTimeout(()=>restorePositionFor(currentFile, {guardMs:600}), 0); });

      // Sidebar tab
      RED.actions.add("file-browser:show", ()=> RED.sidebar.show("file-browser"));
      RED.sidebar.addTab({
        id:"file-browser", name:"Files", label:"Files", iconClass:"fa fa-files-o",
        content:$root, action:"file-browser:show", enableOnEdit:true, toolbar:null,
        onshow: function(){
          if (!$tree.children().length) loadConfigThenList();
          layoutEditorSoon();
          if (currentFile) restorePositionFor(currentFile, {guardMs:700});
          if (fbDebugEnabled()) DBG.ensurePanel();   // create panel only when master debug is ON
        }
      });

      // Kickoff
      setTimeout(()=>{ if (!$tree.children().length) loadConfigThenList(); }, 0);
    }
  });
})();
</script>
